//! WebAssembly verifier for Kimchi proofs generated by kimchi-mobile.
//!
//! This module provides browser-compatible verification of Kimchi zero-knowledge proofs.
//! The SRS (Structured Reference String) is generated once on initialization and cached.
//!
//! # Usage
//!
//! ```javascript
//! import init, { init_verifier, verify_kimchi_proof } from './kimchi_wasm.js';
//!
//! // Initialize WASM module
//! await init();
//!
//! // Initialize verifier with same SRS size as the prover
//! await init_verifier(14);  // Default: 14 = 16384 rows
//!
//! // Verify a proof
//! const isValid = verify_kimchi_proof(
//!     proofHex,           // From PassportProofResult.proof_bytes
//!     verifierIndexHex,   // From export_verifier_index()
//!     publicInputsHex     // From PassportProofResult.public_inputs (array of hex strings)
//! );
//! ```

use std::sync::OnceLock;

use ark_serialize::CanonicalDeserialize;
use kimchi::circuits::constraints::FeatureFlags;
use kimchi::groupmap::GroupMap;
use kimchi::linearization::expr_linearization;
use kimchi::proof::ProverProof;
use kimchi::verifier::verify;
use kimchi::verifier_index::VerifierIndex;
use mina_curves::pasta::{Fp, Vesta, VestaParameters};
use mina_poseidon::constants::PlonkSpongeConstantsKimchi;
use mina_poseidon::pasta::FULL_ROUNDS;
use mina_poseidon::sponge::{DefaultFqSponge, DefaultFrSponge};
use poly_commitment::ipa::{OpeningProof, SRS};
use poly_commitment::SRS as SRSTrait;
use std::sync::Arc;
use wasm_bindgen::prelude::*;

// Type aliases (same as kimchi-prover)
type VestaBaseSponge = DefaultFqSponge<VestaParameters, PlonkSpongeConstantsKimchi, FULL_ROUNDS>;
type VestaScalarSponge = DefaultFrSponge<Fp, PlonkSpongeConstantsKimchi, FULL_ROUNDS>;
type VestaOpeningProof = OpeningProof<Vesta, FULL_ROUNDS>;

// Cached SRS (generated once on init)
static SRS_CACHE: OnceLock<Arc<SRS<Vesta>>> = OnceLock::new();

/// Initialize panic hook for better error messages in browser console.
#[wasm_bindgen(start)]
pub fn init() {
    #[cfg(feature = "console_error_panic_hook")]
    console_error_panic_hook::set_once();
}

/// Initialize the verifier with a specific SRS size.
/// Must be called before verify_kimchi_proof().
///
/// The SRS (Structured Reference String) is deterministic - given the same size,
/// it produces identical output. This is generated once and cached.
///
/// # Arguments
/// * `srs_log2_size` - Log2 of the SRS size. Default is 14 (16,384 rows).
///   Must match the SRS size used by the prover (from get_srs_log2_size()).
///
/// # Returns
/// * `Ok(())` on success
/// * `Err(JsError)` if initialization fails
#[wasm_bindgen]
pub fn init_verifier(srs_log2_size: Option<u32>) -> Result<(), JsError> {
    let size = srs_log2_size.unwrap_or(14) as usize;
    let depth = 1 << size;

    // Generate SRS if not already cached
    // Note: Using create() instead of create_parallel() since WASM is single-threaded
    SRS_CACHE.get_or_init(|| {
        let srs = SRS::<Vesta>::create(depth);
        Arc::new(srs)
    });

    Ok(())
}

/// Check if the verifier has been initialized.
///
/// # Returns
/// * `true` if init_verifier() has been called successfully
/// * `false` otherwise
#[wasm_bindgen]
pub fn is_verifier_initialized() -> bool {
    SRS_CACHE.get().is_some()
}

/// Verify a Kimchi proof generated by kimchi-mobile.
///
/// # Arguments
/// * `proof_hex` - Hex-encoded MessagePack serialized proof
/// * `verifier_index_hex` - Hex-encoded MessagePack serialized verifier index (without SRS)
/// * `public_inputs_hex` - Array of hex-encoded compressed field elements
///
/// # Returns
/// * `true` if proof is valid
/// * `false` if proof is invalid
///
/// # Errors
/// * If verifier is not initialized
/// * If proof/verifier_index/public_inputs cannot be decoded
/// * If deserialization fails
#[wasm_bindgen]
pub fn verify_kimchi_proof(
    proof_hex: &str,
    verifier_index_hex: &str,
    public_inputs_hex: Vec<JsValue>,
) -> Result<bool, JsError> {
    // Ensure SRS is initialized
    let srs = SRS_CACHE
        .get()
        .ok_or_else(|| JsError::new("Verifier not initialized. Call init_verifier() first."))?;

    // Decode proof
    let proof_bytes =
        hex::decode(proof_hex).map_err(|e| JsError::new(&format!("Invalid proof hex: {}", e)))?;

    let proof: ProverProof<Vesta, VestaOpeningProof, FULL_ROUNDS> =
        rmp_serde::from_slice(&proof_bytes)
            .map_err(|e| JsError::new(&format!("Failed to deserialize proof: {}", e)))?;

    // Decode verifier index
    let vi_bytes = hex::decode(verifier_index_hex)
        .map_err(|e| JsError::new(&format!("Invalid verifier index hex: {}", e)))?;

    // Deserialize the verifier index, then inject the cached SRS and powers_of_alpha
    let mut verifier_index: VerifierIndex<FULL_ROUNDS, Vesta, SRS<Vesta>> =
        rmp_serde::from_slice(&vi_bytes)
            .map_err(|e| JsError::new(&format!("Failed to deserialize verifier index: {}", e)))?;

    // Inject the cached SRS
    verifier_index.srs = srs.clone();

    // Reconstruct powers_of_alpha from feature flags (skipped during serialization)
    let feature_flags = infer_feature_flags(&verifier_index);
    let (linearization, powers_of_alpha) = expr_linearization(Some(&feature_flags), true);
    verifier_index.powers_of_alpha = powers_of_alpha;
    verifier_index.linearization = linearization;

    // Decode public inputs
    let mut public_inputs: Vec<Fp> = Vec::with_capacity(public_inputs_hex.len());
    for (i, input) in public_inputs_hex.iter().enumerate() {
        let input_str = input
            .as_string()
            .ok_or_else(|| JsError::new(&format!("Public input {} is not a string", i)))?;
        let input_bytes = hex::decode(&input_str)
            .map_err(|e| JsError::new(&format!("Invalid public input {} hex: {}", i, e)))?;
        let fp = Fp::deserialize_compressed(&input_bytes[..]).map_err(|e| {
            JsError::new(&format!("Failed to deserialize public input {}: {}", i, e))
        })?;
        public_inputs.push(fp);
    }

    // Setup group map and verify
    let group_map = <Vesta as poly_commitment::commitment::CommitmentCurve>::Map::setup();

    let result = verify::<FULL_ROUNDS, Vesta, VestaBaseSponge, VestaScalarSponge, VestaOpeningProof>(
        &group_map,
        &verifier_index,
        &proof,
        &public_inputs,
    );

    Ok(result.is_ok())
}

/// Get detailed verification result with error message if verification fails.
///
/// # Arguments
/// * `proof_hex` - Hex-encoded MessagePack serialized proof
/// * `verifier_index_hex` - Hex-encoded MessagePack serialized verifier index (without SRS)
/// * `public_inputs_hex` - Array of hex-encoded compressed field elements
///
/// # Returns
/// * JSON object with { valid: boolean, error?: string }
#[wasm_bindgen]
pub fn verify_kimchi_proof_detailed(
    proof_hex: &str,
    verifier_index_hex: &str,
    public_inputs_hex: Vec<JsValue>,
) -> Result<JsValue, JsError> {
    // Ensure SRS is initialized
    let srs = SRS_CACHE
        .get()
        .ok_or_else(|| JsError::new("Verifier not initialized. Call init_verifier() first."))?;

    // Decode proof
    let proof_bytes = match hex::decode(proof_hex) {
        Ok(b) => b,
        Err(e) => {
            return Ok(make_result_object(
                false,
                Some(format!("Invalid proof hex: {}", e)),
            ));
        }
    };

    let proof: ProverProof<Vesta, VestaOpeningProof, FULL_ROUNDS> =
        match rmp_serde::from_slice(&proof_bytes) {
            Ok(p) => p,
            Err(e) => {
                return Ok(make_result_object(
                    false,
                    Some(format!("Failed to deserialize proof: {}", e)),
                ));
            }
        };

    // Decode verifier index
    let vi_bytes = match hex::decode(verifier_index_hex) {
        Ok(b) => b,
        Err(e) => {
            return Ok(make_result_object(
                false,
                Some(format!("Invalid verifier index hex: {}", e)),
            ));
        }
    };

    let mut verifier_index: VerifierIndex<FULL_ROUNDS, Vesta, SRS<Vesta>> =
        match rmp_serde::from_slice(&vi_bytes) {
            Ok(vi) => vi,
            Err(e) => {
                return Ok(make_result_object(
                    false,
                    Some(format!("Failed to deserialize verifier index: {}", e)),
                ));
            }
        };

    // Inject the cached SRS
    verifier_index.srs = srs.clone();

    // Reconstruct powers_of_alpha from feature flags (skipped during serialization)
    let feature_flags = infer_feature_flags(&verifier_index);
    let (linearization, powers_of_alpha) = expr_linearization(Some(&feature_flags), true);
    verifier_index.powers_of_alpha = powers_of_alpha;
    verifier_index.linearization = linearization;

    // Decode public inputs
    let mut public_inputs: Vec<Fp> = Vec::with_capacity(public_inputs_hex.len());
    for (i, input) in public_inputs_hex.iter().enumerate() {
        let input_str = match input.as_string() {
            Some(s) => s,
            None => {
                return Ok(make_result_object(
                    false,
                    Some(format!("Public input {} is not a string", i)),
                ));
            }
        };
        let input_bytes = match hex::decode(&input_str) {
            Ok(b) => b,
            Err(e) => {
                return Ok(make_result_object(
                    false,
                    Some(format!("Invalid public input {} hex: {}", i, e)),
                ));
            }
        };
        let fp = match Fp::deserialize_compressed(&input_bytes[..]) {
            Ok(f) => f,
            Err(e) => {
                return Ok(make_result_object(
                    false,
                    Some(format!("Failed to deserialize public input {}: {}", i, e)),
                ));
            }
        };
        public_inputs.push(fp);
    }

    // Setup group map and verify
    let group_map = <Vesta as poly_commitment::commitment::CommitmentCurve>::Map::setup();

    let result = verify::<FULL_ROUNDS, Vesta, VestaBaseSponge, VestaScalarSponge, VestaOpeningProof>(
        &group_map,
        &verifier_index,
        &proof,
        &public_inputs,
    );

    match result {
        Ok(_) => Ok(make_result_object(true, None)),
        Err(e) => Ok(make_result_object(
            false,
            Some(format!("Verification failed: {:?}", e)),
        )),
    }
}

/// Helper to create a JS result object
fn make_result_object(valid: bool, error: Option<String>) -> JsValue {
    let obj = js_sys::Object::new();
    js_sys::Reflect::set(&obj, &"valid".into(), &JsValue::from_bool(valid)).unwrap();
    if let Some(err) = error {
        js_sys::Reflect::set(&obj, &"error".into(), &JsValue::from_str(&err)).unwrap();
    }
    obj.into()
}

/// Infer feature flags from the verifier index's optional commitment fields.
/// This is needed because powers_of_alpha is not serialized.
fn infer_feature_flags<SRS>(
    verifier_index: &VerifierIndex<FULL_ROUNDS, Vesta, SRS>,
) -> FeatureFlags {
    use kimchi::circuits::lookup::lookups::{LookupFeatures, LookupPatterns};

    // Infer which optional gates are used based on which commitments are present
    let range_check0 = verifier_index.range_check0_comm.is_some();
    let range_check1 = verifier_index.range_check1_comm.is_some();
    let foreign_field_add = verifier_index.foreign_field_add_comm.is_some();
    let foreign_field_mul = verifier_index.foreign_field_mul_comm.is_some();
    let xor = verifier_index.xor_comm.is_some();
    let rot = verifier_index.rot_comm.is_some();

    // Infer lookup features from lookup_index
    let lookup_features = if let Some(ref lookup_index) = verifier_index.lookup_index {
        LookupFeatures {
            patterns: LookupPatterns {
                xor: lookup_index.lookup_selectors.xor.is_some(),
                lookup: lookup_index.lookup_selectors.lookup.is_some(),
                range_check: lookup_index.lookup_selectors.range_check.is_some(),
                foreign_field_mul: lookup_index.lookup_selectors.ffmul.is_some(),
            },
            joint_lookup_used: lookup_index.lookup_table.len() > 1,
            uses_runtime_tables: lookup_index.runtime_tables_selector.is_some(),
        }
    } else {
        LookupFeatures::default()
    };

    FeatureFlags {
        range_check0,
        range_check1,
        foreign_field_add,
        foreign_field_mul,
        xor,
        rot,
        lookup_features,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_init_verifier() {
        // This test would need to run in a WASM environment
        // For now, just test that the SRS creation works
        let srs = SRS::<Vesta>::create(1 << 10); // Small SRS for testing
        assert!(srs.g.len() > 0);
    }
}
